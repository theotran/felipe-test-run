import React, { PropTypes, Component } from 'react';
import ReactDOMServer from 'react-dom/server';
const $ = require('jquery');
const dt = require('datatables.net-bs');
const buttons = require('datatables.net-buttons-bs');

require('datatables.net-buttons/js/buttons.colVis.js'); // Column visibility
require('datatables.net-buttons/js/buttons.html5.js');  // HTML 5 file export
require('datatables.net-buttons/js/buttons.flash.js');  // Flash file export
require('datatables.net-buttons/js/buttons.print.js');  // Print view button

let simpleGet = key => data => data[key];
let keyGetter = keys => data => keys.map(key => data[key]);

let isEmpty = value => value == null || value === ''; // eslint-disable-line eqeqeq

let getCellValue =
  ({ prop, defaultContent, render }, row) =>
    // Return `defaultContent` if the value is empty.
    !isEmpty(prop) && isEmpty(row[prop]) ? defaultContent : // eslint-disable-line no-nested-ternary
      // Use the render function for the value.
      render ? render(row[prop], row) :
      // Add Commas for Number formatting
      // addCommas ?
      // Otherwise just return the value.
      row[prop];

let getCellClass =
  ({ prop, className }, row) =>
    !isEmpty(prop) && isEmpty(row[prop]) ? 'empty-cell' : // eslint-disable-line no-nested-ternary
      typeof className == 'function' ? className(row[prop], row) : // eslint-disable-line eqeqeq
      className;

// This function accepts an integer, and produces a piece of HTML that shows it nicely with
// some empty space at "thousand" markers.
// Note, these space are not spaces, if you copy paste, they will not be visible.
let valPrettyPrint =
  (orgVal) => {
    // Save after-comma text, if present
  const period = orgVal.indexOf(".");
  const frac = period >= 0 ? orgVal.substr(period) : "";
  // Work on input as an integer
  let val = "" + Math.trunc(orgVal);
  let res = "";
  while (val.length > 0) {
    res = val.substr(Math.max(0, val.length - 3), 3) + res;
    val = val.substr(0, val.length - 3);
    if (val.length > 0) {
      res = "<span class='thousandsSeparator'></span>" + res;
    }
  }
  // Add the saved after-period information
  res += frac;
  return res;
};
// 2056776401.50 = 2,056,776,401.50
let addThousandsCommas = (n) => {
  n = n.toString();
  while (true) {
    var n2 = n.replace(/(\d)(\d{3})($|,|\.)/g, '$1,$2$3');
    if (n == n2) break;
    n = n2
  }
  return n
};

export default class Table extends Component {

  static propTypes = {
    keys: PropTypes.oneOfType([
      PropTypes.arrayOf(PropTypes.string),
      PropTypes.string
    ]).isRequired,

    columns: PropTypes.arrayOf(PropTypes.shape({
      title: PropTypes.string.isRequired,
      prop: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      render: PropTypes.func,
      sortable: PropTypes.bool,
      defaultContent: PropTypes.string,
      width: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      className: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.func
      ])
    })).isRequired,

    dataArray: PropTypes.arrayOf(PropTypes.oneOfType([
      PropTypes.array,
      PropTypes.object
    ])).isRequired,

    buildRowOptions: PropTypes.func,

    sortBy: PropTypes.shape({
      prop: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      order: PropTypes.oneOf([ 'ascending', 'descending' ])
    })
  };
  static defaultProps = {
    buildRowOptions: () => ({}),
    sortBy: {},
  };

  constructor(props) {
    super(props);
    // console.log('Table constructor', this);
    this._headers = [];
    //  bind event handlers in the constructor so they are only bound once for every instance
  }
  static propTypes = {
    keys: PropTypes.oneOfType([
      PropTypes.arrayOf(PropTypes.string),
      PropTypes.string
    ]).isRequired,

    columns: PropTypes.arrayOf(PropTypes.shape({
      title: PropTypes.string.isRequired,
      prop: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      render: PropTypes.func,
      sortable: PropTypes.bool,
      defaultContent: PropTypes.string,
      width: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      className: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.func
      ])
    })).isRequired,

    dataArray: PropTypes.arrayOf(PropTypes.oneOfType([
      PropTypes.array,
      PropTypes.object
    ])).isRequired,

    buildRowOptions: PropTypes.func,

    sortBy: PropTypes.shape({
      prop: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
      ]),
      order: PropTypes.oneOf([ 'ascending', 'descending' ])
    })
  };

  componentDidMount() {
    // console.log('Table componentDidMount', this);
    let { columns, sortBy } = this.props;

    let table = this.getDTMarkup();
    let dtContainer = this.refs.dtContainer;
    let renderedTable = ReactDOMServer.renderToStaticMarkup(table, dtContainer);

    $('#dtContainer').append(renderedTable);

    let jqueryTable = $('#dt');

    // console.log('dtContainer', document.getElementById('dtContainer'));
    jqueryTable.DataTable({ // eslint-disable-line new-cap
      dom: '<"html5buttons"B>lTfgitp',
      buttons: [
        'copy', 'csv', 'excel', 'pdf', 'print'
      ],
      "order": [[ columns.findIndex((col) => col.prop === sortBy.prop), sortBy.order ]],
      "pagingType": 'numbers',
      "bAutoWidth": false,
      "bDestroy": true,
      "fnDrawCallback": function() {
        console.log('datatables fnDrawCallback');
      },

      "initComplete": function(settings, json) {
        this.api().columns('.sum.integer').every(function() {
          const column = this;

          const sum = column
            .data()
            .reduce(function(a, b) {
              let _a = a.toString().split(',').join('');
              let _b = b.toString().split(',').join('');
              return parseInt(_a, 10) + parseInt(_b, 10);
            });

          $(column.footer()).html('' + sum.toLocaleString('en'));
        });
        this.api().columns('.sum.dollar').every(function() {
          const column = this;

          const sum = column
            .data()
            .reduce(function(a, b) {
              let _a = a.toString().split(',').join('');
              let _b = b.toString().split(',').join('');
              return parseInt(_a, 10) + parseInt(_b, 10);
            });

          $(column.footer()).html('$' + sum.toLocaleString('en'));
        });
        this.api().cells('.thousandsCommas').every(function() {
          const cell = this;
          const node = cell.node();
          const num = cell.data();
          $(node).html(addThousandsCommas(num));
        });
        this.api().cells('.valPrettyPrint').every(function() {
          const cell = this;
          const node = cell.node();
          const num = cell.data();
          $(node).html(valPrettyPrint(num));
        });
      }
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    console.log('Table shouldComponentUpdate', this);
    console.log('nextProps', nextProps);
    console.log('nextState', nextState);
    // TODO check if dataArray changes, if so implement componentDidMount code in componentWillUpdate
    return false;
  }

  componentWillUnmount() {
    console.log('Table componentWillUnmount', this);
  }

  getDTMarkup() {
    // console.log('Table getDTMarkup', this);

    let { columns, keys, buildRowOptions, sortBy, dataArray } = this.props;
    console.log('before', dataArray);
    // handled by datatables.net order option
    //-XXX-Initial sorting if specified.-XXX-
    // if (sortBy) {
    //   dataArray = sort(sortBy, dataArray);
    //   console.log('after', dataArray);
    // }
    let headers = columns.map((col, idx) => {
      return (
        <th
          ref={c => this._headers[idx] = c}
          key={idx}
          style={{width: col.width}}
          className={col.className}
          role="columnheader"
          scope="col" >
          <span>{col.title}</span>
        </th>
      );
    });
    let footers = columns.map(() => {
      return (
        <th>
        </th>
      );
    });

    let getKeys = Array.isArray(keys) ? keyGetter(keys) : simpleGet(keys);
    let rows = dataArray.map(
      row =>
        <tr key={getKeys(row)} {...buildRowOptions(row)}>
          {columns.map(
            (col, i) =>
              <td key={i} className={getCellClass(col, row)}>
                {getCellValue(col, row)}
              </td>
          )}
        </tr>
    );

    return (
      <table id="dt" {...this.props}>
        <thead>
          <tr>
            {headers}
          </tr>
        </thead>
        <tfoot>
          <tr>
            {footers}
          </tr>
        </tfoot>
        <tbody>
          {rows.length ? rows :
            <tr>
              <td colSpan={columns.length} className="text-center">No data</td>
            </tr>}
        </tbody>
      </table>
    );
  }

  render() {
    // console.log('Table render', this);
    return (
      <div>
        <div ref="dtContainer" id="dtContainer"></div>
      </div>
    );
  }

}
